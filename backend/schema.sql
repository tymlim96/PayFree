-- =========================================
-- PayFree schema (PostgreSQL)
-- Tables: users, trips, trip_members,
--         trip_invites, password_reset_tokens,
--         expenses, expense_shares, settlements
-- =========================================

-- (1) users
CREATE TABLE IF NOT EXISTS public.users (
    id           integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email        varchar(255) NOT NULL,
    password_hash varchar(60),
    created_at   timestamptz NOT NULL DEFAULT now(),
    full_name    varchar(100) NOT NULL,
    google_id    text,
    -- regular unique (case-sensitive). We'll replace with a case-insensitive unique index below.
    CONSTRAINT users_email_key UNIQUE (email),
    CONSTRAINT users_google_id_key UNIQUE (google_id),
    CONSTRAINT users_auth_path_check
        CHECK (password_hash IS NOT NULL OR google_id IS NOT NULL)
);

ALTER TABLE public.users OWNER TO postgres;

-- (2) trips
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$;

CREATE TABLE IF NOT EXISTS public.trips (
    id             integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    owner_id       integer NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
    name           varchar(120) NOT NULL,
    currency_code  varchar(3)   NOT NULL DEFAULT 'USD',
    created_at     timestamptz  NOT NULL DEFAULT now(),
    updated_at     timestamptz  NOT NULL DEFAULT now(),
    CONSTRAINT trips_name_not_blank CHECK (btrim(name) <> ''),
    CONSTRAINT trips_currency_len CHECK (char_length(currency_code) = 3),
    CONSTRAINT trips_currency_ascii CHECK (upper(currency_code) ~ '^[A-Z]{3}$')
);

CREATE INDEX IF NOT EXISTS trips_owner_id_idx ON public.trips(owner_id);

DROP TRIGGER IF EXISTS set_trips_updated_at ON public.trips;
CREATE TRIGGER set_trips_updated_at
BEFORE UPDATE ON public.trips
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at();

-- Unique trip names per owner, case-insensitive
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_class c
    JOIN pg_namespace n ON n.oid = c.relnamespace
    WHERE c.relkind = 'i' AND c.relname = 'trips_owner_name_ci_uk' AND n.nspname = 'public'
  ) THEN
    CREATE UNIQUE INDEX trips_owner_name_ci_uk
      ON public.trips (owner_id, lower(name));
  END IF;
END$$;

ALTER TABLE public.trips OWNER TO postgres;

-- (3) trip_members
CREATE TABLE IF NOT EXISTS public.trip_members (
  trip_id   integer NOT NULL
            REFERENCES public.trips(id) ON DELETE CASCADE,
  user_id   integer NOT NULL
            REFERENCES public.users(id) ON DELETE CASCADE,
  role      varchar(20) NOT NULL DEFAULT 'member',
  joined_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT trip_members_pkey PRIMARY KEY (trip_id, user_id),
  CONSTRAINT trip_members_role_chk CHECK (role IN ('owner','member'))
);

-- Query helpers
CREATE INDEX IF NOT EXISTS trip_members_trip_idx ON public.trip_members (trip_id);
CREATE INDEX IF NOT EXISTS trip_members_user_idx ON public.trip_members (user_id);

-- Enforce exactly one owner per trip
CREATE UNIQUE INDEX IF NOT EXISTS trip_members_one_owner_per_trip
  ON public.trip_members (trip_id)
  WHERE role = 'owner';

ALTER TABLE public.trip_members OWNER TO postgres;

-- (4) trip_invites
CREATE TABLE IF NOT EXISTS public.trip_invites (
  id          integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  trip_id     integer NOT NULL REFERENCES public.trips(id) ON DELETE CASCADE,
  token       text    NOT NULL,
  created_by  integer NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  created_at  timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT trip_invites_token_key UNIQUE (token)
);

CREATE INDEX IF NOT EXISTS trip_invites_trip_idx    ON public.trip_invites (trip_id);
CREATE INDEX IF NOT EXISTS trip_invites_created_by_idx ON public.trip_invites (created_by);

ALTER TABLE public.trip_invites OWNER TO postgres;

-- (5) password_reset_tokens
CREATE TABLE IF NOT EXISTS public.password_reset_tokens (
  user_id    integer PRIMARY KEY
             REFERENCES public.users(id) ON DELETE CASCADE,
  token_hash text      NOT NULL,
  expires_at timestamptz NOT NULL,
  used       boolean   NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  -- ensure expiry is after creation time
  CONSTRAINT prt_expiry_after_created_chk CHECK (expires_at > created_at)
);

-- Keep token_hash unique globally (very low collision risk but good hygiene)
CREATE UNIQUE INDEX IF NOT EXISTS prt_token_hash_uk ON public.password_reset_tokens (token_hash);

-- Auto-maintain updated_at
DROP TRIGGER IF EXISTS prt_set_updated_at ON public.password_reset_tokens;
CREATE TRIGGER prt_set_updated_at
BEFORE UPDATE ON public.password_reset_tokens
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at();

ALTER TABLE public.password_reset_tokens OWNER TO postgres;

-- (6) expenses
CREATE TABLE IF NOT EXISTS public.expenses (
  id               integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  trip_id          integer NOT NULL
                    REFERENCES public.trips(id) ON DELETE CASCADE,
  paid_by_user_id  integer NOT NULL
                    REFERENCES public.users(id) ON DELETE RESTRICT,
  description      varchar(200) NOT NULL,
  amount_cents     bigint NOT NULL,
  currency_code    varchar(3) NOT NULL,
  split_mode       varchar(10) NOT NULL DEFAULT 'equal',
  created_by       integer NOT NULL
                    REFERENCES public.users(id) ON DELETE RESTRICT,
  created_at       timestamptz NOT NULL DEFAULT now(),
  updated_at       timestamptz NOT NULL DEFAULT now(),

  -- quality checks
  CONSTRAINT expenses_amount_cents_check CHECK (amount_cents > 0),
  CONSTRAINT expenses_split_mode_check   CHECK (split_mode IN ('equal','manual')),
  CONSTRAINT expenses_desc_not_blank     CHECK (btrim(description) <> ''),
  CONSTRAINT expenses_currency_ascii     CHECK (upper(currency_code) ~ '^[A-Z]{3}$')
);

-- Make sure payer & creator belong to the trip
-- ALTER TABLE public.expenses
--   ADD CONSTRAINT expenses_payer_is_member_fk
--     FOREIGN KEY (trip_id, paid_by_user_id)
--     REFERENCES public.trip_members (trip_id, user_id)
--     ON DELETE RESTRICT;

-- ALTER TABLE public.expenses
--   ADD CONSTRAINT expenses_creator_is_member_fk
--     FOREIGN KEY (trip_id, created_by)
--     REFERENCES public.trip_members (trip_id, user_id)
--     ON DELETE RESTRICT;

-- Indexes
-- List/search by trip fast, keep good ORDER BY created_at performance
CREATE INDEX IF NOT EXISTS expenses_trip_created_idx
  ON public.expenses (trip_id, created_at DESC);

-- If you often query “what did user X pay for?”
CREATE INDEX IF NOT EXISTS expenses_payer_idx
  ON public.expenses (paid_by_user_id);

-- updated_at trigger
DROP TRIGGER IF EXISTS set_expenses_updated_at ON public.expenses;
CREATE TRIGGER set_expenses_updated_at
BEFORE UPDATE ON public.expenses
FOR EACH ROW
EXECUTE FUNCTION public.set_updated_at();

ALTER TABLE public.expenses OWNER TO postgres;

-- (7) expense_shares
CREATE TABLE IF NOT EXISTS public.expense_shares (
  expense_id  integer NOT NULL
              REFERENCES public.expenses(id) ON DELETE CASCADE,
  user_id     integer NOT NULL
              REFERENCES public.users(id)    ON DELETE CASCADE,
  share_cents bigint  NOT NULL,
  CONSTRAINT expense_shares_pkey PRIMARY KEY (expense_id, user_id),
  CONSTRAINT expense_shares_share_cents_check CHECK (share_cents >= 0)
);

-- Helpful index for "what are this user's shares?"
CREATE INDEX IF NOT EXISTS expense_shares_user_idx
  ON public.expense_shares(user_id);

------------------------------------------------------------------------------
-- Trigger: user must be a member of the expense's trip
-- (checks membership against public.trip_members)
------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.es_check_member() RETURNS trigger
LANGUAGE plpgsql AS $$
DECLARE
  v_trip_id integer;
BEGIN
  -- Determine the expense's trip_id
  SELECT e.trip_id INTO v_trip_id
  FROM public.expenses e
  WHERE e.id = NEW.expense_id;

  IF v_trip_id IS NULL THEN
    RAISE EXCEPTION 'Expense % does not exist', NEW.expense_id
      USING ERRCODE = 'foreign_key_violation';
  END IF;

  -- Ensure the user is a member of that trip
  IF NOT EXISTS (
    SELECT 1
    FROM public.trip_members tm
    WHERE tm.trip_id = v_trip_id
      AND tm.user_id = NEW.user_id
  ) THEN
    RAISE EXCEPTION 'User % is not a member of trip % for expense %',
      NEW.user_id, v_trip_id, NEW.expense_id
      USING ERRCODE = 'foreign_key_violation';
  END IF;

  RETURN NEW;
END; $$;

DROP TRIGGER IF EXISTS es_check_member_biu ON public.expense_shares;
CREATE TRIGGER es_check_member_biu
BEFORE INSERT OR UPDATE ON public.expense_shares
FOR EACH ROW
EXECUTE FUNCTION public.es_check_member();

ALTER TABLE public.expense_shares OWNER TO postgres;

-- (8) settlements
CREATE TABLE IF NOT EXISTS public.settlements (
  id             integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  trip_id        integer NOT NULL
                  REFERENCES public.trips(id) ON DELETE CASCADE,
  from_user_id   integer NOT NULL
                  REFERENCES public.users(id) ON DELETE RESTRICT,
  to_user_id     integer NOT NULL
                  REFERENCES public.users(id) ON DELETE RESTRICT,
  amount_cents   bigint  NOT NULL,
  currency_code  varchar(3) NOT NULL,
  created_by     integer NOT NULL
                  REFERENCES public.users(id) ON DELETE RESTRICT,
  created_at     timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT settlements_amount_cents_check CHECK (amount_cents > 0),
  CONSTRAINT settlements_direction CHECK (from_user_id <> to_user_id),
  CONSTRAINT settlements_currency_ascii CHECK (upper(currency_code) ~ '^[A-Z]{3}$')
);

-- Ensure all involved users are members of the trip
-- ALTER TABLE public.settlements
--   ADD CONSTRAINT settlements_from_is_member_fk
--     FOREIGN KEY (trip_id, from_user_id)
--     REFERENCES public.trip_members (trip_id, user_id)
--     ON DELETE RESTRICT;

-- ALTER TABLE public.settlements
--   ADD CONSTRAINT settlements_to_is_member_fk
--     FOREIGN KEY (trip_id, to_user_id)
--     REFERENCES public.trip_members (trip_id, user_id)
--     ON DELETE RESTRICT;

-- ALTER TABLE public.settlements
--   ADD CONSTRAINT settlements_creator_is_member_fk
--     FOREIGN KEY (trip_id, created_by)
--     REFERENCES public.trip_members (trip_id, user_id)
--     ON DELETE RESTRICT;

-- Indexes
CREATE INDEX IF NOT EXISTS settlements_from_idx ON public.settlements (from_user_id);
CREATE INDEX IF NOT EXISTS settlements_to_idx   ON public.settlements (to_user_id);
-- Better for trip pages (lists newest first)
CREATE INDEX IF NOT EXISTS settlements_trip_created_idx
  ON public.settlements (trip_id, created_at DESC);

ALTER TABLE public.settlements OWNER TO postgres;